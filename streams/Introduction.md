# Introduction

## Motivation

现在，从互联网上消费服务的方式包括许多流数据的例子。既包括从服务中下载，也包括上传到服务中或点对点的数据传输。将数据视为元素流而非其整体是非常有用的，因为它与计算机发送和接收它们的方式相匹配（例如通过TCP），但它往往也是必要的，因为数据集经常变得太大，无法作为一个整体来处理。我们将计算或分析分布在大型集群上，并将其称为 "大数据"，处理它们的整个原则是通过将这些数据按顺序--以流的形式--通过CPU处理

actor 也可以被看作是在处理流：他们发送和接收一系列消息，以便将知识（或数据）从一个地方转移到另一个地方。我们发现，为了在Actor之间实现稳定的流式传输，我们需要实现所有适当的措施，这既繁琐又容易出错，因为除了发送和接收之外，我们还需要注意在这个过程中不要溢出任何缓冲区或邮箱。另一个陷阱是Actor消息可能会丢失，在这种情况下必须重新发送。如果不这样做，会导致接收端出现漏洞

基于这些原因，我们决定将这些问题的解决方案捆绑起来作为Akka Streams API。其目的是提供一种直观和安全的方式来制定流处理设置，这样我们就可以高效地执行这些设置，并且有约束的资源使用，不再出现OutOfMemoryErrors。为了实现这个目标，我们的流需要能够限制它们所采用的缓冲，它们需要能够在消费者跟不上时减慢生产者的速度。这个功能被称为背压，是Akka作为创始成员的Reactive Streams计划的核心。对你来说，这意味着在Akka Streams的设计中已经包含了背压的传播和反应这一难点问题，所以你少了一件需要担心的事情；这也意味着Akka Streams与所有其他Reactive Streams实现无缝互通（其中Reactive Streams接口定义了互通性SPI，而Akka Streams这样的实现则提供了一个不错的用户API）


### Relationship with Reactive Streams

Akka Streams API与Reactive Streams接口完全解耦。Akka Streams的重点是在数据流上制定转换，而Reactive Streams的范围是定义一种通用的机制，即如何在没有损失、缓冲或资源耗尽的情况下将数据跨异步边界移动。

这两者之间的关系是，Akka Streams API是面向最终用户的，而Akka Streams实现内部使用Reactive Streams接口在不同的操作者之间传递数据。出于这个原因，你不会发现Reactive Streams接口和Akka Streams API之间有任何相似之处。这与Reactive Streams项目的期望是一致的，它的主要目的是定义接口，使不同的流式实现可以互操作；Reactive Streams的目的不是描述一个最终用户的API


