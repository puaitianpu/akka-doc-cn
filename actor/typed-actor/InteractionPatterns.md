# Interaction Patterns (actor 互动模式)

## Introduction

在akka中actor之间使用ActorRef[T]来进行交互， T 是actor接收的消息类型，也是所谓的 “协议”。
这样可以保证只有正确的消息才能被发送到actor, 同时也保证了除了actor本身之外，没有其他的actor可以访问到actor的实例内部


## Fire and Forget (发送并忘记)
最基本的方式是使用”tell“, 它有一个特殊的方法名称: `actorRef ! message`

Tell 发送消息是异步的，该方法会立即返回。也就是说语句执行后并不知道消息有没有被接受者处理，
也不知道消息是否被接收到、处理成功或失败。

适用场景:

*  确定消息是否被处理并不重要
*  没有办法对不成功地交互或处理采取行动
*  希望尽量少的创建消息数量，以获得更高的吞吐量(发送响应需要创建两倍的消息数量)

问题:

*  如果消息的流入量超过了行为者的处理能力 收件箱就会被填满，在最坏的情况下会导致JVM崩溃，出现OutOfMemoryError
*  如果消息丢失，发送actor会不知道


## Request-Response (请求响应)


有的交互模式是发送地actor需要从接收的actor哪里返回一条或者多条响应消息
响应的消息可以是一个查询结果，确定消息被接收或处理，或请求-订阅事件

在Akka中响应的actor必须被编码为消息的一个字段(ActorRef)，然后使用该字段发送消息响应

适用场景:

*  订阅一个会返回多条消息的actor

问题:

*  actor很少会把另一个actor的响应作为协议的一部分
*  很难检测到消息有没有被送达或处理
*  除非协议已经包含了一种提供上下文的方式，否则不可能在不引入新的、单独的角色的情况下将交互与一些特定的上下文联系在一起

## Adapted Response (适配响应)

大多数情况下发送的actor不支持也不应该支持接收另一个响应actor的消息。
在这种情况下需要提供一个正确类型的ActorRef，并将响应消息适配为发送者能处理的消息类型

你可以为不同的消息类注册多个消息适配器。每个消息类只能有一个消息适配器，以确保如果重复注册，适配器的数量不会无限制地增长。这也意味着，一个注册的适配器将取代同一个消息类的现有适配器。
如果消息类与给定的类相匹配或者是其子类，那么消息适配器将被使用。已注册的适配体按其注册顺序的相反顺序被试用，即最后一个注册的先被试用。
一个消息适配器（以及返回的ActorRef）与接收角色的生命周期相同。建议在顶层的Behaviors.setup或AbstractBehavior的构造函数中注册适配器，但如果需要的话，也可以稍后注册。
适配器函数在接收行为体中运行，可以安全地访问它的状态，但如果它抛出异常，行为体就会停止。

适用场景:

*  在不同的actor之间进行协议转换
*  订阅一个actor会发回很多消息回来

问题：

*  很难发现消息有没有被送达或处理
*  每个响应消息类型只能进行一次适配，如果注册了新的，旧的就会被替换，例如不同的目标行为者如果使用相同的响应类型，就不能有不同的适配，除非在消息中编码了一些相关的内容
*  除非协议已经包含了一种提供上下文的方式，例如请求id也会在响应中发送，否则不可能在不引入一个新的、单独的行为者的情况下，将一个交互与一些特定的上下文联系起来。

## Request-Response with ask between two actors (两个actor之间使用ask进行交互)

在需要请求-响应存在1:1的情况下的交互模式，可以使用ActorContext上的ask来实现
首先需要一个ActorRef[Response]作为接收着放在消息中，然后将成功的Response或者错误的消息转换为发送actor协议的一部分来回复成功或失败


适用场景:

*  单个的响应查询
*  actor继续下面的操作之前需要知道消息已经被处理
*  准许actor在未及时收到响应时重新发送
*  为了跟踪未完成的消息，不给接收的actor发送更多的消息(背压)
*  上下文应该附加到交互中，但协议不支持（请求id，响应的查询）


问题：

*  只能有一个ask
*  当ask超时，接收者并不知道。仍然可能完成处理，甚至事后才开始处理
*  当ask在接收角色中触发链式ask时。你希望有一个短的超时来响应并回复请求者，但同时你也不希望有很多误报


## Request-Response with ask from outside an Actor (从actor以外的地方发送询问消息)

有时候需要在actor以外的地方发送消息给actor，可以使用Fire and Forget的模式，也可以使用ask来实现
ask的方式返回一个Future[Response]，该Future[Response]要么以成功的响应完成，要么以TimeoutException失败，如果在指定的超时内没有响应

使用ask来实现需要导入akka.actor.typed.scaladsl.AskPattern._(import akka.actor.typed.scaladsl.AskPattern._)
并且隐式导入 Timeout和ActorSystem

适用场景:

*  从actor之前查询actor信息

问题：

*  很容易在返回的Future的回调中意外地关闭掉不安全的状态，因为这些回调会在不同的线程上执行
*  一次ask只能返回一次
*  ask超时，接收的actor并不知情，会继续完成处理甚至事后才开始处理


## Generic response wrapper (通用的响应包装器)

在许多情况下，响应可以是一个成功的结果，也可以是一个错误（例如命令无效的验证错误）。必须为每一个请求类型定义两个响应类和一个共享的超级类型，这可能是重复的，特别是在集群上下文中，你还必须确保消息可以被序列化以通过网络发送。
为了帮助解决这个问题，Akka中包含了一个通用的状态-响应类型：StatusReply，在所有可以使用ask的地方，还有第二个方法askWithStatus，鉴于响应是StatusReply，它将解包成功的响应并帮助处理验证错误。Akka包含了该类型的预建序列化器，所以在正常的使用情况下，集群应用程序只需要为成功的结果提供一个序列化器。
对于成功的回复不包含实际值而更多的是确认的情况，有一个预先定义的StatusReply.Ack，类型为StatusReply[Done]。

错误最好以描述错误的文本形式发送，但也可以使用异常来附加类型。

## Ignoring replies (忽略答复)

再某些情况下actor某个message会产生响应，但是你可能对于这个响应不感兴趣。在这种情况下可以使用 `system.ignoreRef`将request-response变成一个`fire-and-forget`

`system.ignoreRef` 返回一个忽略任何发送给它的消息的 ActorRef。

`system.ignoreRef` 可以使用ActorContext访问(context.system.ignoreRef)

适用场景:

*  发送消息的协议里面定义了回应，但是对于这个回应不感兴趣

问题：

*  如果不小心把它当作普通的ActorRef传来传去，可能会导致演员与演员之间的交互中断
*  当从演员系统外执行请求时使用它，会导致请求返回的Future超时，因为它永远不会完成。
*  watch它是合法的，但是它永远不会终止，因此你永远不会从它那里收到一个Terminated信号。


## Send Future result to self (将Future的结果发给自己)

在actor中调用一个返回Future的API并且想在内部使用返回的值时，使用 ActorContext的 `pipeToSelf`方法

适用场景:

*  actor中访问外部返回Future的API
*  当Future完成后，actor内部需要继续处理
*  保留原始的ActorContext，并在Future完成后使用

问题：

*  为结果添加包装消息的模板

## Per session child Actor (每次会话都参与的子actor)

在某些情况下，对请求的完整响应只能在收集了其他角色的多个答案后才能创建并发送回来。
对于这类交互，将工作委托给每个 "会话 "的子角色可能是个好办法。
这个子行为体还可以包含任意逻辑来实现重试、超时失败、斩尾、进度检查等。

请注意，这基本上就是ask的实现方式，如果你需要的只是一个超时的单一响应，最好使用ask。

创建子程序时，会有它需要的ActorContext，包括一个可以响应的ActorRef。
当有了完整的结果后，子代就会用结果进行响应，然后自己停止。

适用场景:

*  一个传入的请求在建立一个结果之前需要与其他角色进行多次交互，例如几个结果的聚合
*  需要处理至少一次发送的确定和重试message


问题：

*  子actor有生命周期，必须管理以免造成资源泄漏
*  增加了复杂度，因为每一个这样的子程序都可以与其他子程序和父程序同时执行。

## General purpose response aggregator (通用的响应聚合器)

这与上面的Per session子Actor模式类似。有时你可能最终会重复同样的聚合回复的方式，并希望将其提取到一个可重用的Actor中。

这种模式有很多变体，这就是为什么将其作为一个文档示例而不是Akka的内置行为提供的原因。它的目的是为了根据您的特定需求进行调整。


适用场景:

*  聚合回复在多个地方以相同的方式执行，并且应该被提取到一个更通用的行为体
*  一个传入的请求在建立一个结果之前需要与其他角色进行多次交互，例如几个结果的聚合
*  需要处理至少一次发送的确定和重试message


问题：

*  带有通用类型的消息协议很难实现，因为通用类型在运行时就会被抹去
*  子actor有生命周期，必须管理以免造成资源泄漏
*  增加了复杂度，因为每一个这样的子程序都可以与其他子程序和父程序同时执行。

## Latency tail chopping (延时尾部切割)

这是上述通用响应聚合器模式的一种变体。

该算法的目标是在多个目的行为者可以执行同一件工作的情况下，减少尾部延迟（"砍掉尾部延迟"），在这种情况下，一个行为者偶尔可能会比预期的响应速度更慢。在这种情况下，将相同的工作请求（也称为 "备份请求"）发送给另一个行为者，会导致响应时间的减少--因为多个行为者同时处于重载状态的可能性较小。在Jeff Dean关于实现大型在线服务的快速响应时间的演讲中，对这一技术进行了深入的解释。

这种模式有很多变化，这也是Akka将其作为文档示例而不是内置行为的原因。它的目的是为了根据您的具体需求进行调整。

适用场景:

*  减少较高的延迟百分比和延迟的变化是重要的。
*  "工作 "可以做不止一次，结果相同，例如请求检索信息


问题：

*  当 "工作 "不是幂等的，且只能执行一次时，不能使用。
*  当 "工作 "不是幂等的，且只能执行一次时，不能使用。
*  带有通用类型的消息协议很难实现，因为通用类型在运行时就会被抹去
*  子actor有生命周期，必须管理以免造成资源泄漏


## Scheduling messages to self (给自己安排消息)

比如使用 schedule 定时给自己发送消息


注意: 

*  要访问定时器，你可以从Behaviors.withTimers开始，它将传递一个TimerScheduler实例到函数中。这可以用于任何类型的Behavior，包括receive、receiveMessage，也可以用于setup或任何其他行为。
*  每个定时器都有一个键，如果启动了一个具有相同键的新定时器，前一个定时器将被取消。保证前一个定时器的消息不会被接收，即使在新的定时器启动时，该消息已经在邮箱中被enqueued。
*  同时支持周期性和单条消息定时器
*  TimerScheduler本身是可变的，因为它执行和管理注册预定任务的副作用。
*  TimerScheduler与拥有它的actor的生命周期绑定，并在actor停止时自动取消。
*  Behaviors.withTimers也可以在Behaviors.supervise里面使用，当actor重新启动时，它会自动正确地取消已经启动的定时器，这样新的化身就不会收到来自前一个化身的预定消息。

Schedule periodically

定时发送消息有两种形式

*  fixed-delay - 使用 startTimerWithFixedDelay，发送后续消息之间的延迟将始终是（至少）给定的延迟
*  fixed-rate - 使用startTimerAtFixedRate, 随着时间的推移，执行的频率将满足给定的时间间隔

## Responding to a sharded actor (应对分片的actor)

当Akka Cluster 中使用分片actor时，需要考虑到actor随时会被移动或者钝化

期待回复正常模式是一个ActorRef,通常是一个消息适配器。
这样可以用于分片的actor时，如果ctx.self被发送，但是分片actor被移动那么回信会被发送到死信

另一种方法是在消息中发送实体ID，然后通过分片actor发送回复

